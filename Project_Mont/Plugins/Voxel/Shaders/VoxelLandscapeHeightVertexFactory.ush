// Copyright Voxel Plugin SAS. All Rights Reserved.

#include "Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

float ChunkSize;
float ScaledVoxelSize;
float RawVoxelSize;

Buffer<float> Heights;

SamplerState TextureSampler;
Texture2D<float2> NormalTexture;
uint NormalTextureSize;

struct FVertexFactoryInput
{
	VF_GPUSCENE_DECLARE_INPUT_BLOCK(0)

	uint VertexId : SV_VertexID;

	float3 GetVertexPosition() const
	{
		const uint QuadX = VertexId >> 24;
		const uint QuadY = (VertexId >> 16) & 0xFF;
		const uint HeightIndex = VertexId & 0xFFFF;
		const float Height = Heights[HeightIndex];

		float3 Position;
		Position.x = QuadX * ScaledVoxelSize;
		Position.y = QuadY * ScaledVoxelSize;
		Position.z = Height;
		return Position;
	}
};

#define FPositionOnlyVertexFactoryInput FVertexFactoryInput
#define FPositionAndNormalOnlyVertexFactoryInput FVertexFactoryInput

struct FVertexFactoryInterpolantsVSToPS
{
	float2 LocalPosition : LOCAL_POSITION;

#if NUM_TEX_COORD_INTERPOLATORS
	float4 TexCoords[(NUM_TEX_COORD_INTERPOLATORS + 1) / 2] : TEXCOORD0;
#endif

#if VF_USE_PRIMITIVE_SCENE_DATA
	nointerpolation uint PrimitiveId : PRIMITIVE_ID;
#endif
#if INSTANCED_STEREO
	nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

#if NUM_TEX_COORD_INTERPOLATORS
float2 GetUV(const FVertexFactoryInterpolantsVSToPS Interpolants, const int UVIndex)
{
	float4 UVVector = Interpolants.TexCoords[UVIndex / 2];
	return UVIndex % 2 ? UVVector.zw : UVVector.xy;
}

void SetUV(inout FVertexFactoryInterpolantsVSToPS Interpolants, const int UVIndex, const float2 InValue)
{
	FLATTEN
	if (UVIndex % 2)
	{
		Interpolants.TexCoords[UVIndex / 2].zw = InValue;
	}
	else
	{
		Interpolants.TexCoords[UVIndex / 2].xy = InValue;
	}
}
#endif

struct FVertexFactoryIntermediates
{
	float3 Position;
	FSceneDataIntermediates SceneData;
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

uint VertexFactoryGetPrimitiveId(const FVertexFactoryInterpolantsVSToPS Interpolants)
{
#if VF_USE_PRIMITIVE_SCENE_DATA
	return Interpolants.PrimitiveId;
#else
	return 0;
#endif
}

float4 VertexFactoryGetTranslatedPrimitiveVolumeBounds(const FVertexFactoryInterpolantsVSToPS Interpolants)
{
	const FPrimitiveSceneData PrimitiveData = GetPrimitiveData(VertexFactoryGetPrimitiveId(Interpolants));
	return float4(LWCToFloat(LWCAdd(PrimitiveData.ObjectWorldPosition, ResolvedView.PreViewTranslation)), PrimitiveData.ObjectRadius);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates = (FVertexFactoryIntermediates)0;
	Intermediates.Position = Input.GetVertexPosition();
	Intermediates.SceneData = VF_GPUSCENE_GET_INTERMEDIATES(Input);
	return Intermediates;
}

FMaterialVertexParameters GetMaterialVertexParameters(const FVertexFactoryInput Input, const FVertexFactoryIntermediates Intermediates, const float3 WorldPosition, const half3x3 TangentToLocal)
{
#if VOXEL_ENGINE_VERSION >= 503
	FMaterialVertexParameters Parameters = MakeInitializedMaterialVertexParameters();
#else
	FMaterialVertexParameters Parameters = (FMaterialVertexParameters)0;
#endif
	Parameters.SceneData = Intermediates.SceneData;
	Parameters.WorldPosition = WorldPosition;
	Parameters.PreSkinnedPosition = WorldPosition;
	Parameters.PreSkinnedNormal = TangentToLocal[2];

#if 0 // TODO
	{
		float3 Normal;
#if WITH_VERTEX_NORMALS
		Normal = normalize(Input.VertexNormal);
#else
		Normal = SampleVoxelNormal(
			Parameters,
			Normal_Texture,
			TextureSampler,
			Normal_TextureIndex,
			Normal_TextureSize,
			Normal_Texture_Size,
			Normal_Texture_InvSize,
			0);
#endif

		const half3 TangentX = abs(Normal.x) > 0.99f ? float3(0, 1, 0) : float3(1, 0, 0);
		const half3 TangentZ = Normal;
		const half3 TangentY = cross(TangentZ, TangentX);

		float3x3 TangentToLocal;
		TangentToLocal[0] = normalize(cross(TangentY, TangentZ));
		TangentToLocal[1] = normalize(TangentY);
		TangentToLocal[2] = normalize(TangentZ);

		float3x3 TangentToWorld = mul(TangentToLocal, GetLocalToWorld3x3(Parameters));
		TangentToWorld[0] = normalize(TangentToWorld[0]);
		TangentToWorld[1] = normalize(TangentToWorld[1]);
		TangentToWorld[2] = normalize(TangentToWorld[2]);

		Parameters.TangentToWorld = TangentToWorld;
	}
#endif

#if NUM_MATERIAL_TEXCOORDS_VERTEX > 0
	Parameters.TexCoords[0] = Input.GetVertexPosition().xy / RawVoxelSize;
#endif

	return Parameters;
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(const FVertexFactoryInput Input, const FVertexFactoryIntermediates Intermediates, const FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;
	Interpolants.LocalPosition = Input.GetVertexPosition().xy;

#if VF_USE_PRIMITIVE_SCENE_DATA
	Interpolants.PrimitiveId = Intermediates.SceneData.PrimitiveId;
#endif

#if NUM_TEX_COORD_INTERPOLATORS
	float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
	GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
	GetCustomInterpolators(VertexParameters, CustomizedUVs);

	UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
	{
		SetUV(Interpolants, CoordinateIndex, CustomizedUVs[CoordinateIndex]);
	}
#endif

	return Interpolants;
}

FMaterialPixelParameters GetMaterialPixelParameters(const FVertexFactoryInterpolantsVSToPS Interpolants, const float4 SvPosition)
{
	FMaterialPixelParameters Parameters = MakeInitializedMaterialPixelParameters();
	Parameters.PrimitiveId = VertexFactoryGetPrimitiveId(Interpolants);
	Parameters.TwoSidedSign = 1;
	Parameters.UnMirrored = 1;

#if NUM_TEX_COORD_INTERPOLATORS
	UNROLL
	for (int CoordinateIndex = 0; CoordinateIndex < NUM_TEX_COORD_INTERPOLATORS; CoordinateIndex++)
	{
		Parameters.TexCoords[CoordinateIndex] = GetUV(Interpolants, CoordinateIndex);
	}
#endif

	{
		const float2 UVs = Interpolants.LocalPosition / ScaledVoxelSize / ChunkSize;

#if INTELLISENSE_PARSER
		uint4 Octahedron_Corners;
#else
		const uint4 Octahedron_Corners = asuint(NormalTexture.GatherRed(TextureSampler, UVs));
#endif

		const float2 Octahedron0 = float2(
			ByteToFloat(Octahedron_Corners[0] & 0xFF),
			ByteToFloat(Octahedron_Corners[0] >> 8));

		const float2 Octahedron1 = float2(
			ByteToFloat(Octahedron_Corners[1] & 0xFF),
			ByteToFloat(Octahedron_Corners[1] >> 8));

		const float2 Octahedron2 = float2(
			ByteToFloat(Octahedron_Corners[2] & 0xFF),
			ByteToFloat(Octahedron_Corners[2] >> 8));

		const float2 Octahedron3 = float2(
			ByteToFloat(Octahedron_Corners[3] & 0xFF),
			ByteToFloat(Octahedron_Corners[3] >> 8));

		const float3 Normal0 = OctahedronToUnitVector(Octahedron0 * 2.f - 1.f);
		const float3 Normal1 = OctahedronToUnitVector(Octahedron1 * 2.f - 1.f);
		const float3 Normal2 = OctahedronToUnitVector(Octahedron2 * 2.f - 1.f);
		const float3 Normal3 = OctahedronToUnitVector(Octahedron3 * 2.f - 1.f);

		const float3 Normal = normalize(InterpolateGather(Normal0, Normal1, Normal2, Normal3, UVs, NormalTextureSize));

		const half3 TangentX = abs(Normal.x) > 0.99f ? float3(0, 1, 0) : float3(1, 0, 0);
		const half3 TangentZ = Normal;
		const half3 TangentY = cross(TangentZ, TangentX);

		float3x3 TangentToLocal;
		TangentToLocal[0] = normalize(cross(TangentY, TangentZ));
		TangentToLocal[1] = normalize(TangentY);
		TangentToLocal[2] = normalize(TangentZ);

		float3x3 TangentToWorld = mul(TangentToLocal, GetLocalToWorld3x3(Parameters));
		TangentToWorld[0] = normalize(TangentToWorld[0]);
		TangentToWorld[1] = normalize(TangentToWorld[1]);
		TangentToWorld[2] = normalize(TangentToWorld[2]);

		Parameters.WorldNormal = normalize(TransformVector(Normal, GetLocalToWorld3x3(Parameters)));
		Parameters.TangentToWorld = TangentToWorld;
	}

	return Parameters;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

half3x3 VertexFactoryGetTangentToLocal(const FVertexFactoryInput Input, const FVertexFactoryIntermediates Intermediates)
{
	return half3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
}

///////////////////////////////////////////////////////////////////////////////

float4 VertexFactoryGetWorldPosition(const FVertexFactoryInput Input, const FVertexFactoryIntermediates Intermediates)
{
	return TransformLocalToTranslatedWorld(Intermediates.Position, Intermediates.SceneData.InstanceData.LocalToWorld);
}
float4 VertexFactoryGetWorldPosition(const FPositionOnlyVertexFactoryInput Input)
{
	return TransformLocalToTranslatedWorld(Input.GetVertexPosition(), VF_GPUSCENE_GET_INTERMEDIATES(Input).InstanceData.LocalToWorld);
}

///////////////////////////////////////////////////////////////////////////////

float3 VertexFactoryGetWorldNormal(const FVertexFactoryInput Input, const FVertexFactoryIntermediates Intermediates)
{
	const FPrimitiveSceneData PrimitiveData = VF_GPUSCENE_GET_INTERMEDIATES(Input).Primitive;
	return RotateLocalToWorld(float3(0, 0, 1), PrimitiveData.LocalToWorld, PrimitiveData.InvNonUniformScale);
}
float3 VertexFactoryGetWorldNormal(const FPositionAndNormalOnlyVertexFactoryInput Input)
{
	const FPrimitiveSceneData PrimitiveData = VF_GPUSCENE_GET_INTERMEDIATES(Input).Primitive;
	return RotateLocalToWorld(float3(0, 0, 1), PrimitiveData.LocalToWorld, PrimitiveData.InvNonUniformScale);
}

///////////////////////////////////////////////////////////////////////////////

float4 VertexFactoryGetRasterizedWorldPosition(const FVertexFactoryInput Input, const FVertexFactoryIntermediates Intermediates, const float4 InWorldPosition)
{
	return InWorldPosition;
}
float3 VertexFactoryGetPositionForVertexLighting(const FVertexFactoryInput Input, const FVertexFactoryIntermediates Intermediates, const float3 TranslatedWorldPosition)
{
	return TranslatedWorldPosition;
}

float4 VertexFactoryGetPreviousWorldPosition(const FVertexFactoryInput Input, const FVertexFactoryIntermediates Intermediates)
{
    return mul(float4(Intermediates.Position, 1), UE_504_SWITCH(LWCMultiplyTranslation, DFMultiplyTranslationDemote)(Intermediates.SceneData.InstanceData.PrevLocalToWorld, ResolvedView.PrevPreViewTranslation));
}

struct FVertexFactoryInputDummy
{
	VF_GPUSCENE_DECLARE_INPUT_BLOCK(0)
};
#undef FPositionAndNormalOnlyVertexFactoryInput
#define FPositionAndNormalOnlyVertexFactoryInput FVertexFactoryInputDummy
#include "/Engine/Private/VertexFactoryDefaultInterface.ush"
#undef FPositionAndNormalOnlyVertexFactoryInput
#define FPositionAndNormalOnlyVertexFactoryInput FVertexFactoryInput