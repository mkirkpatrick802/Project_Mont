// Copyright Voxel Plugin SAS. All Rights Reserved.

#include "VoxelGraphNode_CallTerminalGraph.h"
#include "VoxelGraphTracker.h"
#include "VoxelGraphToolkit.h"
#include "VoxelGraphNodeRef.h"
#include "VoxelTerminalGraph.h"
#include "VoxelFunctionLibraryAsset.h"
#include "Nodes/VoxelGraphNode_Input.h"

void UVoxelGraphNode_CallTerminalGraph::AllocateDefaultPins()
{
	ON_SCOPE_EXIT
	{
		Super::AllocateDefaultPins();
	};

	const UVoxelTerminalGraph* BaseTerminalGraph = GetBaseTerminalGraph();

	const bool bHasExecNodes =
		BaseTerminalGraph &&
		BaseTerminalGraph->HasExecNodes();

	OnChangedPtr = MakeSharedVoid();
	{
		UEdGraphPin* Pin = CreatePin(
			EGPD_Input,
			FVoxelPinType::Make<bool>().GetEdGraphPinType(),
			FVoxelGraphConstants::PinName_EnableNode);

		Pin->PinToolTip = "If true, will run executable nodes inside this graph";
		Pin->PinFriendlyName = INVTEXT("Run Execution");
		Pin->DefaultValue = "true";
		Pin->bHidden = !bHasExecNodes;
	}

	GVoxelGraphTracker->OnTerminalGraphTranslated(*BaseTerminalGraph).Add(FOnVoxelGraphChanged::Make(OnChangedPtr, this, [=]
	{
		const UVoxelTerminalGraph* NewBaseTerminalGraph = GetBaseTerminalGraph();
		const bool bNewHasExecNodes =
			NewBaseTerminalGraph &&
			NewBaseTerminalGraph->HasExecNodes();

		if (bNewHasExecNodes != bHasExecNodes)
		{
			// Reconstruct node to ensure graph is recompiled,
			// so that EnableNode default becomes false in FVoxelGraphEditorInterface::Translate
			ReconstructNode();
		}
	}));

	AddPins();

	if (!BaseTerminalGraph)
	{
		return;
	}

	const FOnVoxelGraphChanged InputOrOutputChanged = FOnVoxelGraphChanged::Make(OnChangedPtr, this, [this]
	{
		ReconstructNode();
	});

	GVoxelGraphTracker->OnInputChanged(*BaseTerminalGraph).Add(InputOrOutputChanged);
	GVoxelGraphTracker->OnOutputChanged(*BaseTerminalGraph).Add(InputOrOutputChanged);
	GVoxelGraphTracker->OnTerminalGraphMetaDataChanged(*BaseTerminalGraph).Add(FOnVoxelGraphChanged::Make(OnChangedPtr, this, [this]
	{
		RefreshNode();
	}));

	CachedOptionalPins.Reset();

	for (const FGuid& Guid : BaseTerminalGraph->GetInputs())
	{
		const FVoxelGraphInput& Input = BaseTerminalGraph->FindInputChecked(Guid);
		const FName PinUniqueName = *Guid.ToString();

		UEdGraphPin* GraphPin = CreatePin(
			EGPD_Input,
			Input.Type.GetEdGraphPinType(),
			PinUniqueName);

		GraphPin->PinFriendlyName = FText::FromName(Input.Name);

		for (const UEdGraphNode* Node : BaseTerminalGraph->GetEdGraph().Nodes)
		{
			if (!Node->IsA<UVoxelGraphNode_Input>())
			{
				continue;
			}

			const UVoxelGraphNode_Input* InputNode = CastChecked<UVoxelGraphNode_Input>(Node);
			if (InputNode->Guid != Guid ||
				!InputNode->bExposeDefaultPin)
			{
				continue;
			}

			CachedOptionalPins.Add(GraphPin);
			break;
		}

		if (Input.DefaultValue.GetType().HasPinDefaultValue())
		{
			Input.DefaultValue.ApplyToPinDefaultValue(*GraphPin);
			GraphPin->AutogeneratedDefaultValue = GraphPin->DefaultValue;
		}
	}

	for (const FGuid& Guid : BaseTerminalGraph->GetOutputs())
	{
		const FVoxelGraphOutput& Output = BaseTerminalGraph->FindOutputChecked(Guid);
		const FName PinUniqueName = *Guid.ToString();

		UEdGraphPin* GraphPin = CreatePin(
			EGPD_Output,
			Output.Type.GetEdGraphPinType(),
			PinUniqueName);

		GraphPin->PinFriendlyName = FText::FromName(Output.Name);
	}
}

FText UVoxelGraphNode_CallTerminalGraph::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	const UVoxelTerminalGraph* BaseTerminalGraph = GetBaseTerminalGraph();
	if (!BaseTerminalGraph)
	{
		return INVTEXT("Empty");
	}

	return FText::FromString(BaseTerminalGraph->GetDisplayName());
}

FLinearColor UVoxelGraphNode_CallTerminalGraph::GetNodeTitleColor() const
{
	const UVoxelTerminalGraph* BaseTerminalGraph = GetBaseTerminalGraph();
	if (!BaseTerminalGraph)
	{
		return FLinearColor::Gray;
	}

	if (BaseTerminalGraph->HasExecNodes())
	{
		return FColorList::Orange;
	}
	else
	{
		return FLinearColor::Gray;
	}
}

FText UVoxelGraphNode_CallTerminalGraph::GetTooltipText() const
{
	const UVoxelTerminalGraph* BaseTerminalGraph = GetBaseTerminalGraph();
	if (!BaseTerminalGraph)
	{
		return {};
	}

	FString Description = BaseTerminalGraph->GetMetadata().Description;
	if (!Description.IsEmpty())
	{
		Description += "\n\n";
	}
	Description += "GUID: " + BaseTerminalGraph->GetGuid().ToString(EGuidFormats::DigitsWithHyphens);

	return FText::FromString(Description);
}

FSlateIcon UVoxelGraphNode_CallTerminalGraph::GetIconAndTint(FLinearColor& OutColor) const
{
	const UVoxelTerminalGraph* BaseTerminalGraph = GetBaseTerminalGraph();
	if (!BaseTerminalGraph)
	{
		return {};
	}

	if (BaseTerminalGraph->HasExecNodes())
	{
		return FSlateIcon("VoxelStyle", "VoxelGraph.Execute");
	}
	else
	{
		return FSlateIcon("EditorStyle", "GraphEditor.Function_16x");
	}
}

bool UVoxelGraphNode_CallTerminalGraph::IsPinOptional(const UEdGraphPin& Pin) const
{
	return CachedOptionalPins.Contains(&Pin);
}

void UVoxelGraphNode_CallTerminalGraph::JumpToDefinition() const
{
	const UVoxelTerminalGraph* BaseTerminalGraph = GetBaseTerminalGraph();
	if (!BaseTerminalGraph)
	{
		return;
	}

	FVoxelUtilities::FocusObject(BaseTerminalGraph);
}

FName UVoxelGraphNode_CallTerminalGraph::GetPinCategory(const UEdGraphPin& Pin) const
{
	if (Pin.GetFName() == FVoxelGraphConstants::PinName_EnableNode ||
		Pin.GetFName() == FVoxelGraphConstants::PinName_GraphParameter)
	{
		return {};
	}

	FGuid Guid;
	if (!ensure(FGuid::Parse(Pin.GetName(), Guid)))
	{
		return {};
	}

	const UVoxelTerminalGraph* BaseTerminalGraph = GetBaseTerminalGraph();
	if (!ensure(BaseTerminalGraph))
	{
		return {};
	}

	if (Pin.Direction == EGPD_Input)
	{
		const FVoxelGraphInput* Input = BaseTerminalGraph->FindInput(Guid);
		if (!ensure(Input))
		{
			return {};
		}

		return *Input->Category;
	}
	else
	{
		check(Pin.Direction == EGPD_Output);

		const FVoxelGraphOutput* Output = BaseTerminalGraph->FindOutput(Guid);
		if (!ensure(Output))
		{
			return {};
		}

		return *Output->Category;
	}
}

TSharedRef<IVoxelNodeDefinition> UVoxelGraphNode_CallTerminalGraph::GetNodeDefinition()
{
	return MakeVoxelShared<FVoxelNodeDefinition_CallTerminalGraph>(*this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

TSharedPtr<const IVoxelNodeDefinition::FNode> FVoxelNodeDefinition_CallTerminalGraph::GetInputs() const
{
	const TSharedRef<FCategoryNode> RootNode = FNode::MakeRoot(true);
	RootNode->AddPin(FVoxelGraphConstants::PinName_EnableNode);
	RootNode->AddPin(FVoxelGraphConstants::PinName_GraphParameter);

	const UVoxelTerminalGraph* BaseTerminalGraph = Node.GetBaseTerminalGraph();
	if (!BaseTerminalGraph)
	{
		return RootNode;
	}

	for (const FGuid& Guid : BaseTerminalGraph->GetInputs())
	{
		RootNode->FindOrAddCategory(BaseTerminalGraph->FindInputChecked(Guid).Category)->AddPin(FName(Guid.ToString()));
	}

	return RootNode;
}

TSharedPtr<const IVoxelNodeDefinition::FNode> FVoxelNodeDefinition_CallTerminalGraph::GetOutputs() const
{
	const TSharedRef<FCategoryNode> RootNode = FNode::MakeRoot(false);

	const UVoxelTerminalGraph* BaseTerminalGraph = Node.GetBaseTerminalGraph();
	if (!BaseTerminalGraph)
	{
		return RootNode;
	}

	for (const FGuid& Guid : BaseTerminalGraph->GetOutputs())
	{
		RootNode->FindOrAddCategory(BaseTerminalGraph->FindOutputChecked(Guid).Category)->AddPin(FName(Guid.ToString()));
	}

	return RootNode;
}