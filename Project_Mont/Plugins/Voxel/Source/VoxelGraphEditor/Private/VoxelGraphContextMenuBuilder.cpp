// Copyright Voxel Plugin SAS. All Rights Reserved.

#include "VoxelGraphContextMenuBuilder.h"
#include "VoxelNodeLibrary.h"
#include "VoxelGraphSchema.h"
#include "VoxelGraphToolkit.h"
#include "VoxelGraphTracker.h"
#include "VoxelGraphSchemaAction.h"
#include "VoxelTerminalGraph.h"
#include "Nodes/VoxelGraphNode.h"
#include "Nodes/VoxelNode_MakeValue.h"
#include "Widgets/SVoxelPinTypeSelector.h"
#include "Nodes/VoxelGraphNode_CallFunction.h"
#include "SchemaActions/VoxelGraphExpandFunctionSchemaAction.h"
#include "SchemaActions/VoxelGraphCollapseToFunctionSchemaAction.h"
#include "ToolMenu.h"

void FVoxelGraphContextMenuBuilder::Build(
	UToolMenu& Menu,
	UGraphNodeContextMenuContext& Context)
{
	VOXEL_FUNCTION_COUNTER();

	if (!ensure(Context.Graph))
	{
		return;
	}

	const TSharedPtr<FVoxelGraphToolkit> Toolkit = FVoxelGraphToolkit::Get(Context.Graph);
	if (!ensure(Toolkit))
	{
		return;
	}

	const FVoxelGraphContextMenuBuilder ContextActions(Menu, Context, *Toolkit);
	ContextActions.Build();
}

void FVoxelGraphContextMenuBuilder::Build() const
{
	VOXEL_FUNCTION_COUNTER();

	const UVoxelTerminalGraph* TerminalGraph = Context.Graph->GetTypedOuter<UVoxelTerminalGraph>();
	if (!ensure(TerminalGraph))
	{
		return;
	}

	if (const UEdGraphPin* Pin = Context.Pin)
	{
		FToolMenuSection& Section = Menu.FindOrAddSection("EdGraphSchemaPinActions");

		if (Pin->bOrphanedPin)
		{
			if (Pin->LinkedTo.Num() > 0)
			{
				Section.AddMenuEntry(FGraphEditorCommands::Get().BreakPinLinks);
			}
			else
			{
				Section.AddMenuEntry(
					"RemovePin",
					INVTEXT("Remove pin"),
					INVTEXT("Remove this orphaned pin"),
					FSlateIcon(),
					FUIAction(
						MakeLambdaDelegate([=]
						{
							GetDefault<UVoxelGraphSchema>()->ResetPinToAutogeneratedDefaultValue(ConstCast(Pin), true);
						})
					)
				);
			}

			return;
		}

		if (Pin->LinkedTo.Num() > 0)
		{
			Section.AddMenuEntry(FGraphEditorCommands::Get().BreakPinLinks);
		}

		if (UVoxelGraphNode* Node = Cast<UVoxelGraphNode>(Pin->GetOwningNode()))
		{
			if (Node->CanRemovePin_ContextMenu(*Pin))
			{
				Section.AddMenuEntry(
					"RemovePin",
					INVTEXT("Remove pin"),
					INVTEXT("Remove this pin"),
					FSlateIcon(),
					FUIAction(
						MakeLambdaDelegate([=]
						{
							Node->RemovePin_ContextMenu(ConstCast(*Pin));
						})
					)
				);
			}

			if (Node->CanSplitPin(*Pin))
			{
				Section.AddMenuEntry(FGraphEditorCommands::Get().SplitStructPin);
			}

			if (Node->CanRecombinePin(*Pin))
			{
				Section.AddMenuEntry(FGraphEditorCommands::Get().RecombineStructPin);
			}
		}

		if (Pin->Direction == EGPD_Input && Pin->LinkedTo.Num() == 0)
		{
			Section.AddMenuEntry(FGraphEditorCommands::Get().ResetPinToDefaultValue);
		}
	}

	if (const UEdGraphNode* Node = Context.Node)
	{
		{
			FToolMenuSection& Section = Menu.AddSection("VoxelGraphNodeEdit", INVTEXT("Node Actions"));
			Section.AddMenuEntry(FGenericCommands::Get().Delete);
			Section.AddMenuEntry(FGenericCommands::Get().Cut);
			Section.AddMenuEntry(FGenericCommands::Get().Copy);
			Section.AddMenuEntry(FGenericCommands::Get().Duplicate);
		}

		{
			FToolMenuSection& Section = Menu.AddSection("EdGraphSchemaOrganization", INVTEXT("Organization"));
			Section.AddSubMenu("Alignment", INVTEXT("Alignment"), FText(), FNewMenuDelegate::CreateLambda([](FMenuBuilder& InMenuBuilder)
			{
				InMenuBuilder.BeginSection("EdGraphSchemaAlignment", INVTEXT("Align"));
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().AlignNodesTop);
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().AlignNodesMiddle);
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().AlignNodesBottom);
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().AlignNodesLeft);
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().AlignNodesCenter);
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().AlignNodesRight);
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().StraightenConnections);
				InMenuBuilder.EndSection();

				InMenuBuilder.BeginSection("EdGraphSchemaDistribution", INVTEXT("Distribution"));
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().DistributeNodesHorizontally);
				InMenuBuilder.AddMenuEntry(FGraphEditorCommands::Get().DistributeNodesVertically);
				InMenuBuilder.EndSection();
			}));
		}

		if (const UVoxelGraphNode* VoxelNode = Cast<UVoxelGraphNode>(Node))
		{
			bool bHasCategories = false;
			if (VoxelNode->InputPinCategories.Num() > 1 ||
				VoxelNode->OutputPinCategories.Num() > 1)
			{
				bHasCategories = true;
			}
			else
			{
				if (VoxelNode->InputPinCategories.Num() == 1 &&
					!VoxelNode->InputPinCategories.Array()[0].IsNone())
				{
					bHasCategories = true;
				}
				else if (
					VoxelNode->OutputPinCategories.Num() == 1 &&
					!VoxelNode->OutputPinCategories.Array()[0].IsNone())
				{
					bHasCategories = true;
				}
			}

			if (bHasCategories)
			{
				FToolMenuSection& Section = Menu.AddSection("VoxelGraphNodeCategories", INVTEXT("Categories Actions"));

				Section.AddMenuEntry(
					"CollapseCategories",
					INVTEXT("Collapse categories"),
					INVTEXT("Collapse all pin categories"),
					FSlateIcon(),
					FUIAction(MakeLambdaDelegate([TargetNode = ConstCast(VoxelNode)]
					{
						TargetNode->CollapsedInputCategories = TargetNode->InputPinCategories;
						TargetNode->CollapsedOutputCategories = TargetNode->OutputPinCategories;
					}),
					MakeLambdaDelegate([=]
					{
						return
							VoxelNode->InputPinCategories.Num() != VoxelNode->CollapsedInputCategories.Num() ||
							VoxelNode->OutputPinCategories.Num() != VoxelNode->CollapsedOutputCategories.Num();
					}))
				);

				Section.AddMenuEntry(
					"ExpandCategories",
					INVTEXT("Expand categories"),
					INVTEXT("Expand all pin categories"),
					FSlateIcon(),
					FUIAction(MakeLambdaDelegate([TargetNode = ConstCast(VoxelNode)]
					{
						TargetNode->CollapsedInputCategories = {};
						TargetNode->CollapsedOutputCategories = {};
					}),
					MakeLambdaDelegate([=]
					{
						return
							VoxelNode->CollapsedInputCategories.Num() > 0 ||
							VoxelNode->CollapsedOutputCategories.Num() > 0;
					}))
				);
			}
		}

		if (VOXEL_DEBUG)
		{
			FToolMenuSection& Section = Menu.AddSection("VoxelGraphNodeAdvanced", INVTEXT("Advanced"));
			Section.AddMenuEntry(
				"ReconstructNode",
				INVTEXT("Reconstruct node"),
				INVTEXT("Reconstruct this node"),
				FSlateIcon(),
				FUIAction(
					MakeLambdaDelegate([=]
					{
						const FVoxelTransaction Transaction(ConstCast(Node), "Reconstruct node");
						ConstCast(Node)->ReconstructNode();
					})
				)
			);
		}
	}

	if (!Context.Pin &&
		Context.Graph)
	{
		{
			FToolMenuSection& Section = Menu.FindOrAddSection("VoxelGraphNodeEdit");
			Section.AddMenuEntry(FGraphEditorCommands::Get().FindReferences);
		}

		const int32 NumSelectedNodes = Toolkit.GetSelectedNodes().Num();
		if (NumSelectedNodes > 0)
		{
			if (UEdGraph* Graph = ConstCast(Context.Graph))
			{
				FToolMenuSection& Section = Menu.FindOrAddSection("EdGraphSchemaOrganization");

				Section.AddMenuEntry(
					"CollapseToFunction",
					INVTEXT("Collapse to Function"),
					INVTEXT("Collapse to Function"),
					{},
					FUIAction(MakeLambdaDelegate([=]
					{
						FVoxelGraphSchemaAction_CollapseToFunction Action;
						Action.PerformAction(Graph, nullptr, FVector2D::ZeroVector, true);
					}))
				);

				if (NumSelectedNodes == 1 &&
					Context.Node &&
					Context.Node->IsA<UVoxelGraphNode_CallFunction>())
				{
					Section.AddMenuEntry(
						"ExpandFunction",
						INVTEXT("Expand Function"),
						INVTEXT("Expand Function"),
						{},
						FUIAction(MakeLambdaDelegate([=]
						{
							FVoxelGraphSchemaAction_ExpandFunction Action;
							Action.PerformAction(Graph, nullptr, FVector2D::ZeroVector, true);
						}))
					);
				}
			}
		}
	}

	if (UVoxelGraphNode* Node = ConstCast(Cast<UVoxelGraphNode>(Context.Node.Get())))
	{
		FToolMenuSection& DebugSection = Menu.FindOrAddSection("DebugSection");
		DebugSection.InitSection("DebugSection", INVTEXT("Debug"), FToolMenuInsert({}, EToolMenuInsertType::First));

		if (Node->bEnableDebug)
		{
			DebugSection.AddMenuEntry(
				"StopDebug",
				INVTEXT("Stop debugging"),
				INVTEXT("Stop debugging this node"),
				{},
				FUIAction(
					MakeLambdaDelegate([Node]
					{
						Node->bEnableDebug = false;
						GVoxelGraphTracker->NotifyEdGraphNodeChanged(*Node);
					})
				)
			);
		}
		else
		{
			DebugSection.AddMenuEntry(
				"StartDebug",
				INVTEXT("Debug node"),
				INVTEXT("Debug this node"),
				{},
				FUIAction(
					MakeLambdaDelegate([Node]
					{
						for (const TObjectPtr<UEdGraphNode>& OtherNode : Node->GetGraph()->Nodes)
						{
							if (UVoxelGraphNode* OtherVoxelNode = Cast<UVoxelGraphNode>(OtherNode.Get()))
							{
								if (OtherVoxelNode->bEnableDebug)
								{
									OtherVoxelNode->bEnableDebug = false;
								}
							}
						}

						Node->bEnableDebug = true;
						GVoxelGraphTracker->NotifyEdGraphNodeChanged(*Node);
					})
				)
			);
		}
	}

	if (UVoxelGraphNode* Node = ConstCast(Cast<UVoxelGraphNode>(Context.Node.Get())))
	{
		FToolMenuSection& PreviewSection = Menu.FindOrAddSection("PreviewSection");
		PreviewSection.InitSection("PreviewSection", INVTEXT("Preview"), FToolMenuInsert({}, EToolMenuInsertType::First));

		if (Node->bEnablePreview)
		{
			PreviewSection.AddMenuEntry(
				"StopPreview",
				INVTEXT("Stop previewing"),
				INVTEXT("Stop previewing this node"),
				{},
				FUIAction(
					MakeLambdaDelegate([Node]
					{
						const FVoxelTransaction Transaction(Node, "Stop previewing");
						Node->bEnablePreview = false;
					})
				)
			);
		}
		else
		{
			PreviewSection.AddMenuEntry(
				"StartPreview",
				INVTEXT("Preview node"),
				INVTEXT("Preview this node"),
				{},
				FUIAction(
					MakeLambdaDelegate([Node]
					{
						const FVoxelTransaction Transaction(Node, "Start previewing");

						for (const TObjectPtr<UEdGraphNode>& OtherNode : Node->GetGraph()->Nodes)
						{
							if (UVoxelGraphNode* OtherVoxelNode = Cast<UVoxelGraphNode>(OtherNode.Get()))
							{
								if (OtherVoxelNode->bEnablePreview)
								{
									const FVoxelTransaction OtherTransaction(OtherVoxelNode, "Stop previewing");
									OtherVoxelNode->bEnablePreview = false;
								}
							}
						}

						Node->bEnablePreview = true;
					})
				)
			);
		}
	}

	if (!Context.Pin)
	{
		FToolMenuSection& Section = Menu.FindOrAddSection("VoxelGraphNodeEdit");
		Section.AddMenuEntry(FGraphEditorCommands::Get().FindReferences);
	}

	const UEdGraphPin* Pin = Context.Pin;
	if (!Pin ||
		!ensure(Pin->GetOwningNode()) ||
		!ensure(Pin->GetOwningNode()->GetGraph()) ||
		Pin->bOrphanedPin ||
		Pin->bNotConnectable)
	{
		return;
	}

	FToolMenuSection& Section = Menu.FindOrAddSection("EdGraphSchemaPinActions");

	if (UVoxelGraphNode* Node = Cast<UVoxelGraphNode>(Pin->GetOwningNode()))
	{
		FVoxelPinTypeSet Types;
		if (Node->CanPromotePin(*Pin, Types))
		{
			const FVoxelPinType CurrentPinType = Pin->PinType;

			TVoxelArray<FVoxelPinType> TypesList = Types.GetTypes().Array();
			if (TypesList.Num() > 2 ||
				(TypesList.Num() == 2 && TypesList[0].GetInnerType() != TypesList[1].GetInnerType()))
			{
				Section.AddSubMenu(
					"PromotePin",
					INVTEXT("Convert pin"),
					INVTEXT("Convert this pin"),
					MakeLambdaDelegate([=](const FToolMenuContext&) -> TSharedRef<SWidget>
					{
						return
							SNew(SVoxelPinTypeSelector)
							.AllowedTypes(Types)
							.OnTypeChanged_Lambda([=](FVoxelPinType NewType)
							{
								const FVoxelTransaction Transaction(Pin, "Convert pin");
								if (CurrentPinType.IsBuffer())
								{
									NewType = NewType.GetBufferType();
								}
								Node->PromotePin(ConstCast(*Pin), NewType);
							})
							.OnCloseMenu_Lambda([=]
							{
								FSlateApplication::Get().ClearAllUserFocus();
							});
					})
				);
			}

			if (CurrentPinType.IsBuffer() &&
				Types.Contains(CurrentPinType.GetInnerType()))
			{
				Section.AddMenuEntry(
					"ConvertToUniform",
					INVTEXT("Convert pin to Uniform"),
					INVTEXT("Convert pin to Uniform"),
					{},
					FUIAction(MakeLambdaDelegate([=]
					{
						const FVoxelTransaction Transaction(Pin, "Convert pin to Uniform");
						Node->PromotePin(ConstCast(*Pin), CurrentPinType.GetInnerType());
					}))
				);
			}
			else if (
				!CurrentPinType.IsBuffer() &&
				Types.Contains(CurrentPinType.GetBufferType()))
			{
				Section.AddMenuEntry(
					"ConvertToBuffer",
					INVTEXT("Convert pin to Buffer"),
					INVTEXT("Convert pin to Buffer"),
					{},
					FUIAction(MakeLambdaDelegate([=]
					{
						const FVoxelTransaction Transaction(Pin, "Convert pin to Buffer");
						Node->PromotePin(ConstCast(*Pin), CurrentPinType.GetBufferType());
					}))
				);
			}
		}
	}

	if (!Pin->bNotConnectable)
	{
		if (Pin->Direction == EGPD_Input)
		{
			Section.AddMenuEntry(
				"PromoteToParameter",
				INVTEXT("Promote to parameter"),
				INVTEXT("Promote to parameter"),
				{},
				MakeLambdaDelegate([=]
				{
					FVoxelGraphSchemaAction_NewParameter Action;

					const UEdGraphNode* OwningNode = Pin->GetOwningNode();
					FVector2D Position;
					Position.X = Pin->Direction == EGPD_Input ? OwningNode->NodePosX - 200 : OwningNode->NodePosX + 400;
					Position.Y = OwningNode->NodePosY + 75;

					Action.PerformAction(OwningNode->GetGraph(), ConstCast(Pin), Position, true);
				})
			);
		}

		if (Pin->Direction == EGPD_Input)
		{
			Section.AddMenuEntry(
				"PromoteToInput",
				INVTEXT("Promote to graph input"),
				INVTEXT("Promote to graph input"),
				{},
				MakeLambdaDelegate([=]
				{
					FVoxelGraphSchemaAction_NewGraphInput Action;

					const UEdGraphNode* OwningNode = Pin->GetOwningNode();
					FVector2D Position;
					Position.X = Pin->Direction == EGPD_Input ? OwningNode->NodePosX - 200 : OwningNode->NodePosX + 400;
					Position.Y = OwningNode->NodePosY + 75;

					Action.PerformAction(OwningNode->GetGraph(), ConstCast(Pin), Position, true);
				})
			);

			if (!TerminalGraph->IsMainTerminalGraph())
			{
				Section.AddMenuEntry(
					"PromoteToInput",
					INVTEXT("Promote to function input"),
					INVTEXT("Promote to function input"),
					{},
					MakeLambdaDelegate([=]
					{
						FVoxelGraphSchemaAction_NewFunctionInput Action;

						const UEdGraphNode* OwningNode = Pin->GetOwningNode();
						FVector2D Position;
						Position.X = Pin->Direction == EGPD_Input ? OwningNode->NodePosX - 200 : OwningNode->NodePosX + 400;
						Position.Y = OwningNode->NodePosY + 75;

						Action.PerformAction(OwningNode->GetGraph(), ConstCast(Pin), Position, true);
					})
				);
			}
		}
		else
		{
			Section.AddMenuEntry(
				"PromoteToParameter",
				INVTEXT("Promote to output"),
				INVTEXT("Promote to output"),
				{},
				MakeLambdaDelegate([=]
				{
					FVoxelGraphSchemaAction_NewOutput Action;

					const UEdGraphNode* OwningNode = Pin->GetOwningNode();
					FVector2D Position;
					Position.X = Pin->Direction == EGPD_Input ? OwningNode->NodePosX - 200 : OwningNode->NodePosX + 400;
					Position.Y = OwningNode->NodePosY + 75;

					Action.PerformAction(OwningNode->GetGraph(), ConstCast(Pin), Position, true);
				})
			);
		}

		Section.AddMenuEntry(
			"PromoteToLocalVariable",
			INVTEXT("Promote to local variable"),
			INVTEXT("Promote to local variable"),
			{},
				MakeLambdaDelegate([=]
				{
					FVoxelGraphSchemaAction_NewLocalVariable Action;

					const UEdGraphNode* OwningNode = Pin->GetOwningNode();
					FVector2D Position;
					Position.X = Pin->Direction == EGPD_Input ? OwningNode->NodePosX - 200 : OwningNode->NodePosX + 400;
					Position.Y = OwningNode->NodePosY + 75;

					Action.PerformAction(OwningNode->GetGraph(), ConstCast(Pin), Position, true);
				})
		);

		if (Pin->Direction == EGPD_Input)
		{
			Section.AddMenuEntry(
				"MakeValue",
				INVTEXT("Make Value"),
				INVTEXT("Make Value"),
				{},
				FUIAction(MakeLambdaDelegate([=]
				{
					if (!ensure(Pin))
					{
						return;
					}

					const TSharedPtr<const FVoxelNode> Node = FVoxelNodeLibrary::GetNodeInstance<FVoxelNode_MakeValue>();
					if (!ensure(Node))
					{
						return;
					}

					FVoxelGraphSchemaAction_NewStructNode Action;
					Action.Node = Node;

					const UEdGraphNode* OwningNode = Pin->GetOwningNode();
					FVector2D Position;
					Position.X = Pin->Direction == EGPD_Input ? OwningNode->NodePosX - 200 : OwningNode->NodePosX + 400;
					Position.Y = OwningNode->NodePosY + 75;

					Action.PerformAction(OwningNode->GetGraph(), ConstCast(Pin), Position, true);
				}))
			);
		}
	}
}